# -*- coding: utf-8 -*-
"""Proyecto Final - MeIA 2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14vaOVvHtva1Gk_8lJ8Oqeje4GgTimOGW

**Proyecto Final: Optimizacion de Regresion Lineal con
Descenso del Gradiente**                                                                     
**Jesus Antonio Torres Contreras**
"""

from sklearn.datasets import load_iris
import pandas as pd
import numpy as np

# Cargar los datos como DataFrame
iris = load_iris(as_frame=True)
df = iris.frame

# Renombrar columnas por claridad si lo deseas
df.columns = [col.lower().replace(" (cm)", "").replace(" ", "_") for col in df.columns]

# Extraer las variables necesarias
X = df[['sepal_width', 'petal_width', 'sepal_length']].values  # Variables independientes
y = df['petal_length'].values.reshape(-1, 1)  # Variable dependiente y le aplique un reshape para manejar mas facil los datos

np.random.seed(123)
m, n = X.shape
W = np.zeros((n, 1))
b = 0.0
alpha = 0.01
epocas = 1000

def predicciones(X, y, W, b):
    N = len(y)
    y_pred = X @ W + b
    cost = (1 / (2 * N)) * np.sum((y_pred - y) ** 2)
    return cost

def gradiente(X, y, W, b):
    N = len(y)
    y_pred = X @ W + b
    error = y_pred - y
    dW = (1 / N) * (X.T @ error)
    db = (1 / N) * np.sum(error)
    return dW, db

cost_history = []

for epoch in range(epocas):
    dW, db = gradiente(X, y, W, b)
    W -= alpha * dW
    b -= alpha * db
    cost = predicciones(X, y, W, b)
    cost_history.append(cost)

    if epoch % 100 == 0:
        print(f"Epoca {epoch}: Costo = {cost:.4f}")

import matplotlib.pyplot as plt

plt.plot(cost_history)
plt.xlabel("Iteración")
plt.ylabel("Costo (MSE)")
plt.title("Evolución de la función de costo")
plt.grid(True)
plt.show()

from sklearn.linear_model import LinearRegression
model = LinearRegression()
model.fit(X, y)

print("\nModelo propio:")
print("W:", W.ravel())
print("b:", b)

print("\nModelo con scikit-learn:")
print("W:", model.coef_.ravel())
print("b:", model.intercept_[0])

plt.scatter(X[:, 1], y, color='blue', label="Datos reales")
plt.scatter(X[:, 1], X @ W + b, color='red', label="Predicción")
plt.xlabel("petal_width")
plt.ylabel("petal_length")
plt.title("Predicción vs Real con: petal_width")
plt.legend()
plt.grid(True)
plt.show()